#First converge Cq
#Then look at velocity profiles some time downstream
#Do Richardson extrapolation


import FLOWUnsteady as uns
import FLOWVLM as vlm
import FLOWVPM as vpm
#///////////////////////////////////////////////////////
using CSV   # For reading the simulation data
using DataFrames # For handling CSV data
using Printf   # For formatted output
#/////////////////////////////////////////////////////////

function convergence(P_per_step; run_id=1)

    run_name        = "propeller-convergence-P_per_step$(P_per_step)"        # Unique name
    save_path       = "propeller-convergence-P_per_step$(P_per_step)"                  # Where to save this simulation

    # ----------------- GEOMETRY PARAMETERS ----------------------------------------

    # Rotor geometry
    rotor_file      = "apc10x7.csv"             # Rotor geometry
    data_path       = uns.def_data_path         # Path to rotor database
    pitch           = 0.0                       # (deg) collective pitch of blades
    CW              = false                     # Clock-wise rotation
    xfoil           = true                      # Whether to run XFOIL
    ncrit           = 9                         # Turbulence criterion for XFOIL

    # Discretization
    n               = 30                        # Number of blade elements per blade                             #AFFECTS RESOLUTION
    r               = 1/5                       # Geometric expansion of elements

    # Read radius of this rotor and number of blades
    R, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]

    # ----------------- SIMULATION PARAMETERS --------------------------------------

    # Operating conditions
    RPM             = 9000                      # RPM
    J               = 0.3934                       # Advance ratio Vinf/(nD)
    AOA             = 0                         # (deg) Angle of attack (incidence angle)

    rho             = 1.225                     # (kg/m^3) air density
    mu              = 1.81e-5                   # (kg/ms) air dynamic viscosity
    speedofsound    = 342.35                    # (m/s) speed of sound

    magVinf         = J*RPM/60*(2*R)
    Vinf(X, t)      = magVinf*[cosd(AOA), sind(AOA), 0] # (m/s) freestream velocity vector

    ReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number
    Matip           = 2*pi*RPM/60*R / speedofsound      # Tip Mach number

    println("""
        RPM:    $(RPM)
        Vinf:   $(Vinf(zeros(3), 0)) m/s
        Matip:  $(round(Matip, digits=3))
        ReD:    $(round(ReD, digits=0))
    """)

    # ----------------- SOLVER PARAMETERS ------------------------------------------

    # Aerodynamic solver
    VehicleType     = uns.UVLMVehicle           # Unsteady solver
    # VehicleType   = uns.QVLMVehicle           # Quasi-steady solver
    const_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the
                                                # solution is constant or not
    # Time parameters
    nrevs           = 3       #Essential wakelength start with this. keep at 3             # Number of revolutions in simulation
    nsteps_per_rev  = 140       #time steps. AFFECTS RESOLUTION                # Time steps per revolution                     AFFECTS RESOLUTION
    nsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps
    ttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time

    # VPM particle shedding
    lambda_vpm      = 2.125                     # VPM core overlap
    p_per_step      = P_per_step     #AFFECTS RESOLUTION                 # Sheds per time step #When changing p_per_step                       AFFECTS RESOLUTION
    #p_per_step   = Int(ceil((lambda_vpm * 2*pi)/(nsteps_per_rev*(1/n))))                 #when changing other values to make things better.
    shed_starting   = false  #Was true                    # Whether to shed starting vortex
    shed_unsteady   = true                      # Whether to shed vorticity from unsteady loading
    max_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles

    # Regularization
    sigma_rotor_surf= R/40                      # Rotor-on-VPM smoothing radius
    
                                                # VPM smoothing radius
    sigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)

    # Rotor solver
    vlm_rlx         = 0.7                       # VLM relaxation <-- this also applied to rotors
    hubtiploss_correction = vlm.hubtiploss_nocorrection # Hub and tip loss correction

    # VPM solver
    vpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme
    #vpm_viscous     = vpm.CoreSpreading(mu/rho, sigma_vpm_overwrite, vpm.kernel_gaussianerf)             #Given by ben


    if VehicleType == uns.QVLMVehicle

        uns.vlm.VLMSolver._mute_warning(true)
    end

    # ----------------- 1) VEHICLE DEFINITION --------------------------------------
    println("Generating geometry...")

    # Generate rotor
    rotor = uns.generate_rotor(rotor_file; pitch=pitch,
                                            n=n, CW=CW, blade_r=r,
                                            altReD=[RPM, J, mu/rho],
                                            xfoil=xfoil,
                                            ncrit=ncrit,
                                            data_path=data_path,
                                            verbose=true,
                                            verbose_xfoil=false,
                                            plot_disc=true
                                            );

    println("Generating vehicle...")

    # Generate vehicle
    system = vlm.WingSystem()                   # System of all FLOWVLM objects
    vlm.addwing(system, "Rotor", rotor)

    rotors = [rotor];                           # Defining this rotor as its own system
    rotor_systems = (rotors, );                 # All systems of rotors

    wake_system = vlm.WingSystem()              # System that will shed a VPM wake
                                            # NOTE: Do NOT include rotor when using the quasi-steady solver
    if VehicleType != uns.QVLMVehicle
        vlm.addwing(wake_system, "Rotor", rotor)
    end

    vehicle = VehicleType(   system;
                                rotor_systems=rotor_systems,
                                wake_system=wake_system
                             );




    # ------------- 2) MANEUVER DEFINITION -----------------------------------------
    # Non-dimensional translational velocity of vehicle over time
    Vvehicle(t) = zeros(3)

    # Angle of the vehicle over time
    anglevehicle(t) = zeros(3)

    # RPM control input over time (RPM over `RPMref`)
    RPMcontrol(t) = 1.0

    angles = ()                                 # Angle of each tilting system (none)
    RPMs = (RPMcontrol, )                       # RPM of each rotor system

    maneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)




    # ------------- 3) SIMULATION DEFINITION ---------------------------------------

    Vref = 0.0                                  # Reference velocity to scale maneuver by
    RPMref = RPM                                # Reference RPM to scale maneuver by

    Vinit = Vref*Vvehicle(0)                    # Initial vehicle velocity
    Winit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity

    simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;
                                                    Vinit=Vinit, Winit=Winit);


    # ------------- 4) MONITORS DEFINITIONS ----------------------------------------
    figs, figaxs = [], []                       # Figures generated by monitor

    # Generate rotor monitor
    monitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;
                                                t_scale=RPM/60,        # Scaling factor for time in plots
                                                t_lbl="Revolutions",   # Label for time axis
                                                out_figs=figs,
                                                out_figaxs=figaxs,
                                                save_path=save_path,
                                                run_name=run_name,
                                                figname="rotor monitor",
                                                disp_conv = false #Just look at the csv when finding stuff
                                                )


    # ------------- 5) RUN SIMULATION ----------------------------------------------
    println("Running simulation...")
    #//////////////////////////////////////////////////////////////////////////////////////////////////////
    println("Running simulation $run_id with P_per_step = $P_per_step (Total steps: $nsteps)...")
    #///////////////////////////////////////////////////////////////////////////////////////////////////

    uns.run_simulation(simulation, nsteps;
                        # ----- SIMULATION OPTIONS -------------
                        Vinf=Vinf,
                        rho=rho, mu=mu, sound_spd=speedofsound,
                        # ----- SOLVERS OPTIONS ----------------
                        p_per_step=p_per_step,
                        max_particles=max_particles,
                        vpm_viscous=vpm_viscous,
                        sigma_vlm_surf=sigma_rotor_surf,
                        sigma_rotor_surf=sigma_rotor_surf,
                        sigma_vpm_overwrite=sigma_vpm_overwrite,
                        vlm_rlx=vlm_rlx,
                        hubtiploss_correction=hubtiploss_correction,
                        shed_unsteady=shed_unsteady,
                        shed_starting=shed_starting,
                        extra_runtime_function=monitor_rotor,
                        # ----- OUTPUT OPTIONS ------------------
                        save_path=save_path,
                        run_name=run_name,
                        sigmafactor_vpm = 1.3, #This should be ignored iif sigma vpm override is nothing
                        #vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter #Added by ben expensive operation takes a long time to run for mach or bracket error
                        );

    #/////////////////////////////////////////////////////////////////////////////////////////////////
    # --- PULL OUT CQ VALUE (f_i) ---
    # The data is saved to a CSV file.
    rotor_name    = "Rotor"
    
    data_filename = joinpath(save_path, run_name * "_convergence.csv")
    df = DataFrame(CSV.File(data_filename))
    
    # Richardson extrapolation uses the converged solution, which is the last step.
    # The last step should be nsteps, which is the last row of the DataFrame.
    f_i = df.CQ_1[end] 
    
    println("Final CQ for P_per_step=$P_per_step is $f_i\n")
    return f_i
    #/////////////////////////////////////////////////////////////////////////////////////////////////

end


# ==============================================================================
# 2. CONVERGENCE STUDY (Varying P_per_step in Constrained Range [1-9])
# ==============================================================================

# Define the experimental value (as provided by the user)
const Cq_experimental = 0.00911957 

# Define the constrained, non-uniform range of P_per_step values.
P_steps = [1, 2, 3, 4, 5, 6, 7, 8] 
results = Dict{Int, Float64}() 

println("--- Starting Constrained P_per_step Convergence Check (Range: 1 to 9) ---")
@printf("Experimental CQ Value: %.6f\n", Cq_experimental)

# --- Step 1: Run Simulations and Collect Data ---
for (i, P_step) in enumerate(P_steps)
    @printf "Running simulation %d/%d with P_per_step = %d...\n" i length(P_steps) P_step
    
    # Call the original function
    f_i = convergence(P_step, run_id=i) 
    
    results[P_step] = f_i
end


# --- Step 2: Calculate Percentage Change and Find MER ---
# Using the 'let' block to fix the Julia scope error
let f_prev = missing, MER = missing, MER_found = false, target_tolerance = 0.00125 

    println("\n\n--- P_per_step CONVERGENCE RESULTS ---")
    println("| P_per_step | Solution (CQ) | % Change from previous | Experimental Error (%) |")
    println("|:----------:|:-------------:|:-----------------------:|:-----------------------:|")

    for P_step in P_steps
        f_i = results[P_step]
        
        # Calculate Experimental Relative Error
        experimental_error = abs(f_i - Cq_experimental) / Cq_experimental * 100
        
        if ismissing(f_prev)
            # First point (P_per_step=1)
            @printf("| %-10d | %.6f | N/A | %.4f%% |\n", P_step, f_i, experimental_error)
        else
            # Calculate the absolute percentage difference (relative to current f_i)
            pct_change = abs(f_i - f_prev) / f_i
            
            # Check for convergence (the "flattening out" point)
            if !MER_found && pct_change <= target_tolerance
                MER = P_step
                MER_found = true
                # Highlight the point where convergence is reached
                @printf("| **%-10d** | **%.6f** | **%.4f%%** (MER)| **%.4f%%** |\n", P_step, f_i, pct_change * 100, experimental_error)
            else
                @printf("| %-10d | %.6f | %.4f%% | %.4f%% |\n", P_step, f_i, pct_change * 100, experimental_error)
            end
        end
        
        f_prev = f_i # f_prev is updated within the let scope
    end


    # --- Step 3: Summary and Conclusion ---
    println("\n--- SUMMARY ---")
    
    # Determine the final value for the summary
    if MER_found
        f_final = results[MER]
        @printf("Minimum Effective Resolution (MER) found at P_per_step = %d.\n", MER)
        @printf("Converged CQ Best Estimate: %.6f\n", f_final)
    else
        f_final = results[P_steps[end]]
        MER = P_steps[end]
        @printf("WARNING: Solution did not meet %.1f%% convergence tolerance within the range.\n", target_tolerance * 100)
        @printf("Best Estimate (Finest Grid, P_per_step = %d): %.6f\n", MER, f_final)
    end
    
    # Calculate and print the error for the final best estimate
    final_experimental_error = abs(f_final - Cq_experimental) / Cq_experimental * 100
    @printf("Final Experimental Error: %.4f%%\n", final_experimental_error)

end
